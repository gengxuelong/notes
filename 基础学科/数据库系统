# 数据库系统

一个万物互联的时代正在成型

学习数据库，是个很急迫的事情

## 关系模型

##### 树状结构，

人们曾经尝试使用树状结构（层次化结构）去管理数据库中的数据。可是一旦子层数据和父层结构存在联系，则层状结构变成了网网状结构。存储效率和访问效率网状结构均非常低。

***

##### 关系模型：

用集合表达数据与数据之间的关系

关系模型得到DBMS厂商的广泛认可。

Oracle是最先发布关系模型的数据库管理系统

关系模型也支持了面向对象的功能

1970年，提出关系模型

考察数据库模型从三个方面： 

数据结构，数据操作，完整性约束

关系模型是基于集合论的概念。

N个集合之间的笛卡尔积的子集叫做关系

两个集合做笛卡尔积，结果是任然是一个集合，集合对于笛卡尔积具有闭包。

笛卡尔积：

>给出三个域：
>
>D1=SUPERVISOR = { 张清玫，刘逸 }
>
>D2=SPECIALITY= {计算机专业，信息专业}
>
>D3=POSTGRADUATE = {李勇，刘晨，王敏}
>
>则D1，D2，D3的笛卡尔积为D：
>
>D=D1×D2×D3 ={
>
>(张清玫, 计算机专业, 李勇), 
>
>(张清玫, 计算机专业, 刘晨),
>
>(张清玫, 计算机专业, 王敏),
>
> (张清玫, 信息专业, 李勇),
>
>(张清玫, 信息专业, 刘晨),
>
> (张清玫, 信息专业, 王敏),
>
>(刘逸, 计算机专业, 李勇), 
>
>(刘逸, 计算机专业, 刘晨),
>
>(刘逸, 计算机专业, 王敏),
>
> (刘逸, 信息专业, 李勇),
>
>(刘逸, 信息专业, 刘晨), 
>
>(刘逸, 信息专业, 王敏)
>
>}
>
>这样就把D1,D2,D3这三个集合中的每个元素加以对应组合，形成庞大的集合群。

关系模型——数据表：

![](D:\截图\数据库系统\1.png)

表头： 记录类型，，，关系模式

行： 记录，，，元祖。

列：字段，数据项	，，，属性

单个值： 字段值，，，属性值

##### 超码/超建

>一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。
> 这个集合可以用来区分同一个表中的元组，比如 **ID** 可以作为超码，因为它是唯一的。当一个属性就能区分同一个表中的元组，这个属性就是超码，而且它和同一个表中的任意属性组成集合，这个组合都是超码。
> 举例：**ID** 这个属性，在该表中，任意不同元组都不会取相同的ID值，那么 **ID** 是超码，且 **ID**和任何属性再组成集合，这个集合还是超码，**ID,name**这个集合还是超码。

##### 候选码/候选键

>最小超码
> 超码这个集合中，如果提取它们的某个子集，这个子集是可以用来区分同一个表中的元组，且该子集只有一个元素或者再从中提取的子集无法用来区分同一个表中的元组，这个集合就是候选码。一个关系表中至少有一个候选码。
> 举例：超码的例子中，**ID**也是候选码，但是 **ID,name**不是候选码，因为从这个集合中提取的子集还可以用来区分同一个表中的元组。假如这个表中还有 **name,anothername**，并且这个集合满足候选码条件，那么这个关系中就有 **ID** 和 **name,anothername** 两个候选码

确定候选码的时候 一定要限定使用条件

#### 主码： 

> 被数据库设计者选中的、主要用来在一个关系中区分不同元组的 **候选码**。
>  我们人为取一个关系中的某个候选码，定义为主码并使用。

候选码一般不止一个，任选一个作为主码

##### 辅关键字：

> 未被选中为主码的候选码成为辅关键字

#### 外键：

；；

##### 关系模型的完整性约束：

学生关系模式；num，name ,sex,age,dept(系)

课程关系模式：name ,学分，



#### NULL

空值在实际中有实际需求，关系中允许存在null。代表的含义是不知道或不确定

x == 60 ,如果x 为null，则结果为null 。不为真也不为假

##### 完整性约束之实体完整性约束：

主码不能为NULL

##### 参照的完整性约束：

将某一个属性相对其他一个表设置为外键，这个属性的取值为： 可以为null，如果不为null，取值必须参考另一个表的主键取值

##### 取值的完整性约束，用户约束，企业约束：

用户自己定义各个属性的取值限制

#### 关系模型的数据操作（传统的集合运算）：

关系代数，关系演算：

关系代数： 表达了数据一步一步如何找到的过程

关系演算：更侧重于数据查询的结果

结构化查询语言SQL 是主要基于关系代数的，也基于关系演算。关系代数更加重要

##### 传统集合的并运算：

两个集合的并运算结果还是集合。

关系表的列： 维/度

##### 对于关系集合的并运算：

 当且仅当两个表具有相同的维/度的时候，才能进行并运算

所得的关系集合的维不改变，仅进行行层面的改变

##### 关系集合的差运算：

前提同样是连个表之间具有相同的维

差运算也是在行的角度进行运算，不改变结果的维

在第一个表的基础上去掉两个相同的部分

##### 关系集合的交运算：

前提任然是同维

R交S = R - (R- S)

##### 两个关系集合的笛卡尔积：

![](D:\截图\数据库系统\2.png)

两个关系集合做笛卡尔积，第一个集合是2维，第二个关系集合是3维的，则结果是5维的

> 并交差运算 仅从 行的角度进行运算，列不变。
>
> 笛卡尔积： 从行和列的角度同时运算，即改变行，也改变列。

### 关系模型的完整性约束：

- 实体完整性约束，主码不能为空
- 参照的完整性约束，外键的取值受到限制，可以为空，如果赋值，必须是其参照的表的主键的取值
- 用户定义的约束

### 关系的操作

关系的本质是集合。

- 并交差，针对行维度
- 笛卡尔积：行和列均改变

- 选择运算：

#### 选择运算：

![](D:\截图\数据库系统\3.png)

选择运算：

不改变行，

#### 投影运算

属性变少了，列发生了改变

![](D:\截图\数据库系统\4.png)

#### 连接运算：

从行和列的角度复合运算：

从笛卡尔积所得的结果中再按照要求进行筛选行

![](D:\截图\数据库系统\5.png)

应该一行一行筛选，而不是先笛卡尔积，再删选，笛卡尔积所得的数据量很庞大

#### 相等连接：

运算机理和自然连接一样，只是不去除重复的列

![](D:\截图\数据库系统\6.png)

#### 自然连接：

默认的条件的连接运算，

默认属性：相同属性取值相等

如果没有相同的属性，又强行进行自然连接，所得的结果是笛卡尔积

笛卡尔积是一个很不好的现象，应尽力避免

![](D:\截图\数据库系统\56.png)

#### 外连接运算

如果不希望左边的行信息丢失，则采用左外连接

如果不希望右边的行信息丢失，则采用右外连接

如果两边的信息都不希望丢失，则采用全外连接

![](D:\截图\数据库系统\7.png)

#### 除法运算：

象集：

象集是不包含本身的

![](D:\截图\数据库系统\8.png)

除法是基于象集的

![](D:\截图\数据库系统\9.png)

![](D:\截图\数据库系统\10.png)

上述例子结构为两行

> 符号表达
>
> ![](D:\截图\数据库系统\11.png)

![](D:\截图\数据库系统\12.png)

针对学生选课关系，象集代表一个学生所选的全部课程

学生选课关系表/ 课程信息 结果为：

选择“课程信息” 课程的学生

# 开年第一节课

关系模型 ： 数据模型的一种，数据模型是对客观世界的一种抽象。客观世界是连续无限系统，计算机世界是有限、不连续的系统。

## 考察一个模型要从三个方面考察： 

1. 数据结构
   - 非常单一，只有-》关系： 若干集合的笛卡尔积的子集称为一个关系。所以关系也是一个集合。关系模型基于集合论。关于关系的操作，运算的对象和运算的结果都是关系（集合）。
2. 数据操作
3. 完整性约束
   - 实体完整性：主码不能为空（NULL） NULL 三种状态： 真、假、不确定。某一个值和NULL比较结构为不确定。
   - 参照完整性约束： 外键的取值有限制。要么为空，要么为它所参照的取值。它参照的是另外一个关系的主码。
   - 用户定义的完整性约束：用户可以定义某些属性的取值。

## 最重要的是数据操作（关系代数）：

- 传统的集合运算 ： 
  - 并：两个关系 当且仅当拥有相同的维/度的时候，才可以进行并运算。符号：V（或）
  - 交： 同样是当且仅当具有相同的维 的时候。符号： 反V（且） 。R 交 S = R -(R-S)
  - 差： 当且仅当具有相同的维的时候。  属于前者 且 不属于后者    
  - 笛卡尔积: 

- 关系的专门运算。
  - 选择运算: 只要一部分复合条件的行
  - 投影运算：从列的角度运算，只保留一部分属性。
  - 连接运算： 二维运算，是一个复合运算。R中的一个属性 和 S中的一个属性之间要满足一定的关系。从笛卡尔积中取满足条件的值。
    - 等值连接： 所满足的关系为等值连接。
    - 自然连接： 没给连接条件，默认按照： 相同的属性必须取值相等的原则。
  - 除法运算： 两个关系R和S，相除，找到两者相同的属性或者属性组，得到一个新的关系，出完之后只剩下R中非相同属性部分的属性组。只有那些行满足条件：x属性组的象集 能包含S在y上的投影。
    - 学生表  除以 课程表 = 选择所有课程的学生名单 

![](D:\file\qq\3349495429\FileRecv\MobileFile\关系模型.jpg)

## 讲课一般基于三个关系： 

学生关系 S，课程关系 C，学生选课关系SC

应用题：

1. 找年龄小于18岁的学生姓名：
   - 找到  姓名 属性，条件年龄属性 也在学生表中，同表查询。
     - ![image-20220307113238507](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307113238507.png)

2. 找年龄小于18 的男同学：
3. 所有具有不及格科目的姓名：
   -  同表查询![image-20220307114510139](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307114510139.png)

-- 要尽可能先做选择运算。

-- SC表：有两个个属性： 学生姓名 和 课程号（及其附属）

1. 选修了一号课且二号课的学生
   - 

![image-20220307115159688](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307115159688.png)

2. 选了一号可并且没有选择二号课的学生。
   - 从SC中选择选CNo= ‘1’ 然后再投影 得到SNo 属性  -     CNo2 
3. 找所有没有选一号课的：
   - 从SC中找到选了一号课的行，投影到学号，再用S对学号的投影 - 前者
4. 找仅仅选了一号课的学生（可以利用韦恩图）
   - ![image-20220307120815014](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307120815014.png)
5. 仅仅没选一号课的学生：
   - 选择全部课程学生： 用除法

# 开年第二课

结构化查询语言。

数据库管理系统：

- PostgreSQl 
- OpenGauss    
- mySql

# 第三节课

## SQL语言

数据类型：

查询MySQL 或者 POSTSQL文档。

### 第一个动词： create

创建一个数据库

DBMS 维护数据库中的数据，给用户返回一个操作接口。DBMS数据库管理系统软件。

DBMS有一个监听器，监听是否有一个客户请求链接我。pgAdmin 3   客户端软件，pgadmin 4 是服务器自带的客户端软件，是基于web的，也能用。

首先创建一个数据库，然后创建关系。

-- 表示注释

char(2)  固定字符，必须两个字符，少了自动补齐空格

varchar(20)   可变字符

```sql
select * 
from student;

select sNo,sName,
from student;

选择所有选了课的学生学号
select distinct sNo              //distinct是消除重复行
from sc;

select sNo,sName,sex
from student
where sex = '女' or sex = '男' or sex is null;

select sNo,sName,age,sex
from student
where age beteen 18 and 19 ;  //双闭区间

select * 
from student 
where dNo in ('01');    //等价于 dNo = '01'

select * 
from student 
where dNo in ('01','02');    // dNo = '01' or dNo = '02'

select * 
from student 
where dNo not in ('01','02');  //不包括null值的

select * 
from student 
where dNo not  ('01','02',null);   //没查出来null 值的行。因为他等价的是  。。 or dNo = null ; null 值无法用等号连接

select * 
from student 
where dNo  in ('01','02') or dNo is null;

select * 
from student 
where dNo not in (null);      //未返回任何值，因为null值不能和等号或者不等号匹配

select * 
from student 
where sName like '张%';//任意字符的通配符

select * 
from student 
where sName like '张_';  //单个字符的通配符

select * 
from student 
where sName like '张__'; //两个字符的通配符

如果本身就包含一个下换线呢

select * 
from student 
where sName like 'DB\_%'; //找以DB_开头的

select * 
from student 
where sName like 'DB\_%i__';//找以DB_开头的并且以i做倒数第三个字符

select * 
from student 
where age <= 18 or age > 18;//不包含null值学生

//排序
select * 
from student 
order by age ASC;     DESC 降序，默认升序...null当做最大值来排（posteSQL)。

select * 
from student 
order by dNo,age;

select * 
from student 
order by sex;//可以根据字符格式的数据排序


//聚集函数
查找当有多少名学生
select count(*)
from student;

select count(distinct age)
from student;

select count(sNo)
from student;
```

# 第四次课

count() 函数，不计数null,重复的也计数

distinct  消除重复



查看当前总学分

```sql
select SUM(credit)
from course;
```

查询某个学生所有课程的平均分

```sql
select sNo ,avg(scorce)
from sc
where sNo = '1701'
```

分组：group by  

```sql
select cNo count(*)
from sc 
group by cNo
order by cNo;
```

选修人数大于10 的课程号 和选修人数

对分组之后的数据进行限制用having

```sql
select cNo count(*)
from sc
group by cNo
having count(*)>=10;
```

子查询：

```sql
select *
from student
where dNo = (
	select dNo
    from student
    where sName = 'lihua';
)
```

## 多表连接

```sql
通俗语法
select *
from r1,r2
where r1.a = r2.b;
//没有where时，会出现笛卡尔积
ISO标准写法

```

```sql
select first.cno,second.cpno
from course first,course second
where first.cpno = second.cno
//自连接
```

自然连接：

如果没有匹配的话，会导致丢失行的问题。

外连接： 不会有任何丢失数据，无论匹配与否 左右两表的数据都会保留。

```
select s.*,sc.*
from student s,sc sc
where s.sno = sc.sno; //自然连接
select s.*,sc.*
from student s,sc sc
where s.sno = sc.sno（*）; //左外连接。当没有匹配时，右边增加空行和左边匹配
select s.* ,sc.*
from student s
left （outer） join sc sc
on s.sno = sc.sno;//RSO标准语法，推荐。左外连接
select table1.conlumn ,table2.column 
from table1
cross join table2 (笛卡尔积)
natrual join table2（自然连接）
join table2 using column_name
join table2 on (条件)
left/right/full outer join table2
on (条件)
```

单表查询：

分组和聚集函数

多表查询-

- 嵌套子查询
- 连接查询

逻辑表达正确性



首先分析查询的结构和查询条件

如果查询的结果和条件在一个关系中，则 简单，单表查询

如果结果 和条件 在不同的关系中：

- 子查询，在where子句中用子查询获得条件。不相关子查询，逻辑非常清晰，嵌套多层也应该会。
- 连接

如果我们要查询的结果本身来自于多个关系，条件又来自于另外关系：

- 则不得不用到连接。
- 把两个或者多个关系连接在一起。

逻辑表达:

level1: sql 能执行

level2： SQL能执行，结果正确

level3： SQL能执行，结果正确，逻辑还要正确。逻辑正确能保证SQL在不同平台上都能运行成功。同时分析效率。

逻辑错误  但结果正确的案例：

1. 查询选修了所有课程的学生姓名：

自己不会，就查询了选修课程门数与当前所有课程门数相同的学生	（乾坤大挪移）

exits 关键词

```
查询所有没选001 号课的学生姓名
select sname
from student
where sno not in (
	select sno 
	from sc
	where cno = '001'
)

select sname
from student
where not exists(
	select * 
	from sc
	where sno = student.sno and sno = '001'
) 在子查询中用到了student.sno 这个父查询的关系，子查询不能单独运行。只判断是否存在，不关系具体的赋值。所以exists前没有属性，查询的行也是用* 
只能父查询和子查询顺序查询。
对父查询的每一行，子查询都要扫描一遍

select sno ,sname.sdept
from student s1
where exits (
	select * form student s2
	where s2.sdept = s1.sdept and s2.sname = '刘晨'
);

select sno ,sname 
from student
where dno = (
select dno 
from student
where sname = '刘晨')
in /not in  的子查询都是不相关的子查询，逻辑更加清晰。
而exits /not exits 的子查询很多情况是相关子查询，逻辑比较复杂。
有一些情况用in不能表达，而用exit能表达。
```

关系代数的除法，就是表示全称连词。

SQL没有直接表示除法的语法

全称量词可以表示为存在量词。

存在量词既 exists ，

任意x 有P   ==》 不存在x,使非P



对于任何一门课，只要A选了，那么我也选了。

```sql
select sname 
from student s
where not exists(
	select * 
    from sc
    
)
```

只有关于全称量词 和 蕴含相关时的才用（not） exists。



关于集合的运算：

关系是结合。并交差适用

针对关系的运算：

选择、投影、连接、除法

SQL语言中虽然支持并交差，但是后续开发中 一定要严禁并交差。不允许使用

并：

union

将两个查询的结构 并交差在一起。对于关系：当且仅当列一样的时候才可以

select 子句也可以放在from中。构成视图。后续会讲解

课程只讲解大概。需要自主学习。



insert：

```sql
insert into student (sno,sname)
values()
insert into student
values () //不写类名，默认所有列名都写了。
//插入查询结构
create table s_score(
	sno char(6),
	sname varchar(20),
	avg decimal(5,2)
);
insert into s_score(sno ,sname.avg)
(
	select s.sno,s.sname,v.avgscore
	from student s,(
		select sno,avg(acore) from sc group by sno)
		as v(sno,avgscore)
		where s.sno = v.sno
	)
);
```



update student 

set age = 60

where sno = '001';



delete 

from student

where sno = '001';

DML： insert  update    delete

DDL: create    alter    drop

DCL: grant 授权   revoke 撤销权限





更新的一致性问题：

update student 

set dno  = '05'

where sno = '170407';



select * from department;

插入的学生违反了外键约束。将直接报错。

delete 

from department 

where dno = '01';

报错，student表中 外键dno中有01 的学生。

三种方案：

- 级联student表中01 系的学生直接删除掉
- 让01 系的学生的系更改为null
- 直接不允许删除，报错阻止。默认

在默认条件下如何删除系：

先把系里的学生的系 更改为 null或其他

update sudent 

set dno = null

where dno = '01';



## 索引

因为有管理开销，所有磁盘不能以位为单位，因为这样的话光是记录各个位是够被占用的管理信息就比可用信息大了。所以磁盘以块为单位分配存储空间。

访问磁盘的时间开销：

1. 寻找信息所在的磁道。寻道
2. 旋转等待。
3. 读取，时间可以忽略不计。

针对一个表只能建立一个物理索引（簇索引）

性别是最适合建立簇索引

对于成绩，建立簇索引和一般索引都不恶化时

使用B树和B+ 树



所有的表都应该建立基于主键的主索引。

基于其他数据项的副索引，使用B或B+ 树实现。

基于值单一的项建立物理索引。

```sql
create unique index stuentId
on student(sno);
drop index indexName;
```







## 视图

希望访问的数据在三个表中。

视图仅仅是虚表

把数据从基本表中拿出并重新组织一遍，形成视图。

不能往视图中存储数据。

用户访问SQL效率提高，更加便捷。但是访问效率并没有提高，略有下降，多了查询代码和视图代码拼接整合的步骤

数据更加安全，只让用户有权访问视图，基本表中的无关数据无法再被访问。

with check option





## 事务控制

account(id,balance)

转账业务

update account 

set balance = balance -100

where id = '01';

update account 

set ballance = balance +100

where id = '02';



默认将每条SQL语句当做一条事务

在事务没有提价之前是可以提交的

没有提交运行事务后也能看到结果，可以回滚到未改变前

事务没有提交的时候其他用户是否可以看到改变呢？

可以让看到 也可以不让看到

postresql 默认每条SQL语句都是一个事务，语句前后隐形一个事务定义和事务提交

Oracle是默认提交语句前的所有语句为一个大的事务。货主所运行的所有SQL认为是一个事务。







## 完整性约束

## 访问控制

grant 



## 触发器

trigger and procedure





## 数据库的安全性：

数据库安全层次

 

## 数据库应用设计：

SQL和其他的高级程序语言结合使用

- 将SQL作为函数的参数放入C语言
- 直接将SQL语言引入到C语言



通信区



数据库系统 好好学，一定要保研呀；

一定要提升自己的能力呀；

争取找个女盆友呀





ER模型向关系模型的衍射

经过上两次课的讨论，

数据需求，二义性，隐含需求

将用户需求转化为关系模型

数据库概念设计阶段，采用ER建模技术。

得到概念模型。叫做实体联系模型

对用户的数据需求加以重新表述。

虽然能比较完整的表达用户的数据需求，但是没有办法直接放在数据库中取

数据库中存的都是关系模型，

如何把实体联系模型转换为关系模型呢

如何把ER模型转换为关系模型

要练习打字，提升打字速度啊

那么上两次可讨论了衍射模式规范理论

衍射方法并不是唯一的，并不是都是好的。

两种极端： 都放在一张表中；每个属性都映射为一种关系。

冗余，属性间的依赖关系完全丢失

那些映射是好的，那些是不好的。

关系模式规范化

 关系模式规范化，如何一步一步将关系模式改为满足三范式	

理解明白了不代表能做，课后一定要经过实践，做大量的练习，

自己给自己出一些练习，做老师的练习z

在课程群中可以随时答疑

关系模型中的联系只有一种： 关系

假设，我们根据用户的数据需求，

我们得到的ER模型非常简单，只有两个属性：

学院和 学生。

ER模型 转换为关系模型

冗余容易造成增删改异常

规范化满足第三范式的模式。

我们一般最少要规范化到第三范式的程度

在工程中，不能随便映射，让后在按规范化理论得到满足三范式的结果。

在工程中，我们希望总结出一个方法，使得结果就直接满足三个范式、

把每个实体性映射为一个关系，

将副实体的主码作为主实体的外键

当联系有属性时，则将联系映射为一个弱实体，

通过弱实体，将一个二元关系转化为三元关系

多对多的递归联系: 自己对自己

其实就是多对多的二元联系

新增加一个弱实体型，该弱实体型没有暂时没有属性

新增加弱实体

第一范式： 增加行，原主码消失，出现冗余，不好。

将多值属性分离出去，构成一个弱实体型



ER模型的强实体：

将强实体映射为一个关系。

弱实体，将弱实体也映射为一个关系，可能没有候选码

弱实体，一定会跟强实体有联系的。

两个强实体间一对多的二元联系：

把一方实体作为父实体，将多方的实体作为子实体。



一对一的联系：

一方有可能部分参与，

如果双方全部参与，那么就是严格的一行队一行，可以直接合并。不会产生负面影响

如果一方全部参与，一方部分参与怎么办：

不介意空值可以合并，

把全部参与的一方作为父实体，把部分参与的一方作为子实体

如果双方都是部分参与：

员工 和 汽车

随便选择一个作为主实体

绝大部分员工都有车，员工的参与性强，则车的参与性弱，弱的一方为父实体

