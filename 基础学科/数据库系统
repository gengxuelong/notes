# 数据库系统

一个万物互联的时代正在成型

学习数据库，是个很急迫的事情

## 关系模型

##### 树状结构，

人们曾经尝试使用树状结构（层次化结构）去管理数据库中的数据。可是一旦子层数据和父层结构存在联系，则层状结构变成了网网状结构。存储效率和访问效率网状结构均非常低。

***

##### 关系模型：

用集合表达数据与数据之间的关系

关系模型得到DBMS厂商的广泛认可。

Oracle是最先发布关系模型的数据库管理系统

关系模型也支持了面向对象的功能

1970年，提出关系模型

考察数据库模型从三个方面： 

数据结构，数据操作，完整性约束

关系模型是基于集合论的概念。

N个集合之间的笛卡尔积的子集叫做关系

两个集合做笛卡尔积，结果是任然是一个集合，集合对于笛卡尔积具有闭包。

笛卡尔积：

>给出三个域：
>
>D1=SUPERVISOR = { 张清玫，刘逸 }
>
>D2=SPECIALITY= {计算机专业，信息专业}
>
>D3=POSTGRADUATE = {李勇，刘晨，王敏}
>
>则D1，D2，D3的笛卡尔积为D：
>
>D=D1×D2×D3 ={
>
>(张清玫, 计算机专业, 李勇), 
>
>(张清玫, 计算机专业, 刘晨),
>
>(张清玫, 计算机专业, 王敏),
>
> (张清玫, 信息专业, 李勇),
>
>(张清玫, 信息专业, 刘晨),
>
> (张清玫, 信息专业, 王敏),
>
>(刘逸, 计算机专业, 李勇), 
>
>(刘逸, 计算机专业, 刘晨),
>
>(刘逸, 计算机专业, 王敏),
>
> (刘逸, 信息专业, 李勇),
>
>(刘逸, 信息专业, 刘晨), 
>
>(刘逸, 信息专业, 王敏)
>
>}
>
>这样就把D1,D2,D3这三个集合中的每个元素加以对应组合，形成庞大的集合群。

关系模型——数据表：

![](D:\截图\数据库系统\1.png)

表头： 记录类型，，，关系模式

行： 记录，，，元祖。

列：字段，数据项	，，，属性

单个值： 字段值，，，属性值

##### 超码/超建

>一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一地标识一个元组。
> 这个集合可以用来区分同一个表中的元组，比如 **ID** 可以作为超码，因为它是唯一的。当一个属性就能区分同一个表中的元组，这个属性就是超码，而且它和同一个表中的任意属性组成集合，这个组合都是超码。
> 举例：**ID** 这个属性，在该表中，任意不同元组都不会取相同的ID值，那么 **ID** 是超码，且 **ID**和任何属性再组成集合，这个集合还是超码，**ID,name**这个集合还是超码。

##### 候选码/候选键

>最小超码
> 超码这个集合中，如果提取它们的某个子集，这个子集是可以用来区分同一个表中的元组，且该子集只有一个元素或者再从中提取的子集无法用来区分同一个表中的元组，这个集合就是候选码。一个关系表中至少有一个候选码。
> 举例：超码的例子中，**ID**也是候选码，但是 **ID,name**不是候选码，因为从这个集合中提取的子集还可以用来区分同一个表中的元组。假如这个表中还有 **name,anothername**，并且这个集合满足候选码条件，那么这个关系中就有 **ID** 和 **name,anothername** 两个候选码

确定候选码的时候 一定要限定使用条件

#### 主码： 

> 被数据库设计者选中的、主要用来在一个关系中区分不同元组的 **候选码**。
>  我们人为取一个关系中的某个候选码，定义为主码并使用。

候选码一般不止一个，任选一个作为主码

##### 辅关键字：

> 未被选中为主码的候选码成为辅关键字

#### 外键：

；；

##### 关系模型的完整性约束：

学生关系模式；num，name ,sex,age,dept(系)

课程关系模式：name ,学分，



#### NULL

空值在实际中有实际需求，关系中允许存在null。代表的含义是不知道或不确定

x == 60 ,如果x 为null，则结果为null 。不为真也不为假

##### 完整性约束之实体完整性约束：

主码不能为NULL

##### 参照的完整性约束：

将某一个属性相对其他一个表设置为外键，这个属性的取值为： 可以为null，如果不为null，取值必须参考另一个表的主键取值

##### 取值的完整性约束，用户约束，企业约束：

用户自己定义各个属性的取值限制

#### 关系模型的数据操作（传统的集合运算）：

关系代数，关系演算：

关系代数： 表达了数据一步一步如何找到的过程

关系演算：更侧重于数据查询的结果

结构化查询语言SQL 是主要基于关系代数的，也基于关系演算。关系代数更加重要

##### 传统集合的并运算：

两个集合的并运算结果还是集合。

关系表的列： 维/度

##### 对于关系集合的并运算：

 当且仅当两个表具有相同的维/度的时候，才能进行并运算

所得的关系集合的维不改变，仅进行行层面的改变

##### 关系集合的差运算：

前提同样是连个表之间具有相同的维

差运算也是在行的角度进行运算，不改变结果的维

在第一个表的基础上去掉两个相同的部分

##### 关系集合的交运算：

前提任然是同维

R交S = R - (R- S)

##### 两个关系集合的笛卡尔积：

![](D:\截图\数据库系统\2.png)

两个关系集合做笛卡尔积，第一个集合是2维，第二个关系集合是3维的，则结果是5维的

> 并交差运算 仅从 行的角度进行运算，列不变。
>
> 笛卡尔积： 从行和列的角度同时运算，即改变行，也改变列。

### 关系模型的完整性约束：

- 实体完整性约束，主码不能为空
- 参照的完整性约束，外键的取值受到限制，可以为空，如果赋值，必须是其参照的表的主键的取值
- 用户定义的约束

### 关系的操作

关系的本质是集合。

- 并交差，针对行维度
- 笛卡尔积：行和列均改变

- 选择运算：

#### 选择运算：

![](D:\截图\数据库系统\3.png)

选择运算：

不改变行，

#### 投影运算

属性变少了，列发生了改变

![](D:\截图\数据库系统\4.png)

#### 连接运算：

从行和列的角度复合运算：

从笛卡尔积所得的结果中再按照要求进行筛选行

![](D:\截图\数据库系统\5.png)

应该一行一行筛选，而不是先笛卡尔积，再删选，笛卡尔积所得的数据量很庞大

#### 相等连接：

运算机理和自然连接一样，只是不去除重复的列

![](D:\截图\数据库系统\6.png)

#### 自然连接：

默认的条件的连接运算，

默认属性：相同属性取值相等

如果没有相同的属性，又强行进行自然连接，所得的结果是笛卡尔积

笛卡尔积是一个很不好的现象，应尽力避免

![](D:\截图\数据库系统\56.png)

#### 外连接运算

如果不希望左边的行信息丢失，则采用左外连接

如果不希望右边的行信息丢失，则采用右外连接

如果两边的信息都不希望丢失，则采用全外连接

![](D:\截图\数据库系统\7.png)

#### 除法运算：

象集：

象集是不包含本身的

![](D:\截图\数据库系统\8.png)

除法是基于象集的

![](D:\截图\数据库系统\9.png)

![](D:\截图\数据库系统\10.png)

上述例子结构为两行

> 符号表达
>
> ![](D:\截图\数据库系统\11.png)

![](D:\截图\数据库系统\12.png)

针对学生选课关系，象集代表一个学生所选的全部课程

学生选课关系表/ 课程信息 结果为：

选择“课程信息” 课程的学生

# 开年第一节课

关系模型 ： 数据模型的一种，数据模型是对客观世界的一种抽象。客观世界是连续无限系统，计算机世界是有限、不连续的系统。

## 考察一个模型要从三个方面考察： 

1. 数据结构
   - 非常单一，只有-》关系： 若干集合的笛卡尔积的子集称为一个关系。所以关系也是一个集合。关系模型基于集合论。关于关系的操作，运算的对象和运算的结果都是关系（集合）。
2. 数据操作
3. 完整性约束
   - 实体完整性：主码不能为空（NULL） NULL 三种状态： 真、假、不确定。某一个值和NULL比较结构为不确定。
   - 参照完整性约束： 外键的取值有限制。要么为空，要么为它所参照的取值。它参照的是另外一个关系的主码。
   - 用户定义的完整性约束：用户可以定义某些属性的取值。

## 最重要的是数据操作（关系代数）：

- 传统的集合运算 ： 
  - 并：两个关系 当且仅当拥有相同的维/度的时候，才可以进行并运算。符号：V（或）
  - 交： 同样是当且仅当具有相同的维 的时候。符号： 反V（且） 。R 交 S = R -(R-S)
  - 差： 当且仅当具有相同的维的时候。  属于前者 且 不属于后者    
  - 笛卡尔积: 

- 关系的专门运算。
  - 选择运算: 只要一部分复合条件的行
  - 投影运算：从列的角度运算，只保留一部分属性。
  - 连接运算： 二维运算，是一个复合运算。R中的一个属性 和 S中的一个属性之间要满足一定的关系。从笛卡尔积中取满足条件的值。
    - 等值连接： 所满足的关系为等值连接。
    - 自然连接： 没给连接条件，默认按照： 相同的属性必须取值相等的原则。
  - 除法运算： 两个关系R和S，相除，找到两者相同的属性或者属性组，得到一个新的关系，出完之后只剩下R中非相同属性部分的属性组。只有那些行满足条件：x属性组的象集 能包含S在y上的投影。
    - 学生表  除以 课程表 = 选择所有课程的学生名单 

![](D:\file\qq\3349495429\FileRecv\MobileFile\关系模型.jpg)

## 讲课一般基于三个关系： 

学生关系 S，课程关系 C，学生选课关系SC

应用题：

1. 找年龄小于18岁的学生姓名：
   - 找到  姓名 属性，条件年龄属性 也在学生表中，同表查询。
     - ![image-20220307113238507](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307113238507.png)

2. 找年龄小于18 的男同学：
3. 所有具有不及格科目的姓名：
   -  同表查询![image-20220307114510139](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307114510139.png)

-- 要尽可能先做选择运算。

-- SC表：有两个个属性： 学生姓名 和 课程号（及其附属）

1. 选修了一号课且二号课的学生
   - 

![image-20220307115159688](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307115159688.png)

2. 选了一号可并且没有选择二号课的学生。
   - 从SC中选择选CNo= ‘1’ 然后再投影 得到SNo 属性  -     CNo2 
3. 找所有没有选一号课的：
   - 从SC中找到选了一号课的行，投影到学号，再用S对学号的投影 - 前者
4. 找仅仅选了一号课的学生（可以利用韦恩图）
   - ![image-20220307120815014](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220307120815014.png)
5. 仅仅没选一号课的学生：
   - 选择全部课程学生： 用除法

# 开年第二课

结构化查询语言。

数据库管理系统：

- PostgreSQl 
- OpenGauss    
- mySql

# 第三节课

## SQL语言

数据类型：

查询MySQL 或者 POSTSQL文档。

### 第一个动词： create

创建一个数据库

DBMS 维护数据库中的数据，给用户返回一个操作接口。DBMS数据库管理系统软件。

DBMS有一个监听器，监听是否有一个客户请求链接我。pgAdmin 3   客户端软件，pgadmin 4 是服务器自带的客户端软件，是基于web的，也能用。

首先创建一个数据库，然后创建关系。

-- 表示注释

char(2)  固定字符，必须两个字符，少了自动补齐空格

varchar(20)   可变字符

```sql
select * 
from student;

select sNo,sName,
from student;

选择所有选了课的学生学号
select distinct sNo              //distinct是消除重复行
from sc;

select sNo,sName,sex
from student
where sex = '女' or sex = '男' or sex is null;

select sNo,sName,age,sex
from student
where age beteen 18 and 19 ;  //双闭区间

select * 
from student 
where dNo in ('01');    //等价于 dNo = '01'

select * 
from student 
where dNo in ('01','02');    // dNo = '01' or dNo = '02'

select * 
from student 
where dNo not in ('01','02');  //不包括null值的

select * 
from student 
where dNo not  ('01','02',null);   //没查出来null 值的行。因为他等价的是  。。 or dNo = null ; null 值无法用等号连接

select * 
from student 
where dNo  in ('01','02') or dNo is null;

select * 
from student 
where dNo not in (null);      //未返回任何值，因为null值不能和等号或者不等号匹配

select * 
from student 
where sName like '张%';//任意字符的通配符

select * 
from student 
where sName like '张_';  //单个字符的通配符

select * 
from student 
where sName like '张__'; //两个字符的通配符

如果本身就包含一个下换线呢

select * 
from student 
where sName like 'DB\_%'; //找以DB_开头的

select * 
from student 
where sName like 'DB\_%i__';//找以DB_开头的并且以i做倒数第三个字符

select * 
from student 
where age <= 18 or age > 18;//不包含null值学生

//排序
select * 
from student 
order by age ASC;     DESC 降序，默认升序...null当做最大值来排（posteSQL)。

select * 
from student 
order by dNo,age;

select * 
from student 
order by sex;//可以根据字符格式的数据排序


//聚集函数
查找当有多少名学生
select count(*)
from student;

select count(distinct age)
from student;

select count(sNo)
from student;
```

